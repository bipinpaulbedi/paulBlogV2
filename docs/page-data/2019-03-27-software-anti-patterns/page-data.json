{"componentChunkName":"component---src-templates-blog-post-template-js","path":"/2019-03-27-software-anti-patterns","result":{"data":{"markdownRemark":{"html":"<p><img src=\"/2019-03-27-software-anti-patterns/anti-pattern-patch.jpg\" alt=\"anti-pattern\"></p>\n<p>Image Source : <a href=\"https://unsplash.com/@drosie\">Photo by Donnie Rosie on Unsplash</a></p>\n<p>Software designers talk about design patterns or the best practices for application designing. The choice is between which mistake is easier to correct: under-doing it or overdoing it.</p>\n<p>We keep on adding ingredients to the curry and food is left with no taste. Let’s explore some anti-patterns and explore the pitfalls of Software designing.</p>\n<p><strong>Organisational anti-patterns</strong></p>\n<ul>\n<li>Analysis paralysis - Devoting disproportionate effort to the analysis phase of the project.</li>\n<li>Cash cow - A profitable legacy product that often leads to complacency about new product.</li>\n<li>Design by committee - The result of having many contributors to a design - but no unifying vision.</li>\n<li>Moral hazard - Insulating a decision-maker from the consequences of his or her decision.</li>\n<li>Stovepipe or Silos - A structure that supports mostly up-down flow of data but inhibits cross organisational communication.</li>\n<li>Vendor lock-in - Making a system extensively dependent on an external supplied component.</li>\n</ul>\n<p><strong>Design anti-patterns</strong></p>\n<ul>\n<li>Abstraction inversion - Not exposing implemented functionality required by user, so that they reimplement it using higher level functions.</li>\n<li>Ambiguous viewpoint - Presenting a model (OOAD) without specifying its viewpoint.</li>\n<li>Big ball of mud - A system with no recognisable structure.</li>\n<li>Database as IPC - Using DB as message queue for inter-process communication where a more lightweight mechanism would be suitable.</li>\n<li>Gold plating - Continuing to work on a project well past the point at which extra effort is not adding value.</li>\n<li>Inner - platform effect - A software so customisable as to become poor replica of software development platform.</li>\n<li>Input kludge - Failing to specify and implement handling of possibly invalid inputs.</li>\n<li>Interface bloat - making an interface so powerful that it is extremely difficult to implement.</li>\n<li>Magic push button - Coding implementation logic directly within interface code, without using abstraction.</li>\n<li>Race hazard - Failing to see consequences of different orders of events.</li>\n<li>Stovepipe system - A barely maintainable assemblage of ill-related components.</li>\n</ul>\n<p><strong>OOD anti-patterns</strong></p>\n<ul>\n<li>Anaemic domain model - Use of domain model without business knowledge.</li>\n<li>Base bean - Inheriting functionality from utility class rather than delegating to it.</li>\n<li>Call super - Requiring subclasses to call a superclass’s overridden method.</li>\n<li>Circle ellipse problem - Sub typing variable-types on the bases of value-subtypes.</li>\n<li>Circular dependency - Introducing unnecessary direct or indirect mutual dependencies between objects.</li>\n<li>Constant interface - using interface to define constants.</li>\n<li>God object - Concentrating too many functionalities in a single part of design.</li>\n<li>Object cesspool - Reusing objects whose state does not confirm to the contract of reuse.</li>\n<li>Object orgy - Failing to properly encapsulate objects permitting unrestricted access to their internals.</li>\n<li>Poltergeists - Objects whose sole purpose is to pass information to another object.</li>\n<li>Sequential coupling - A class that requires its method to be called in a particular order.</li>\n<li>Yo-yo problem - A structure that is hard to understand due to excessive fragmentation.</li>\n<li>Dependency hell - Problem with versions of required product.</li>\n<li>DLL hell - Inadequate management of dynamic linked libraries.</li>\n</ul>\n<p><strong>Programming anti-patterns</strong></p>\n<ul>\n<li>Accidental complexity - Introducing unnecessary complexity into a solution.</li>\n<li>Action at distance - Unexpected interaction between widely separated parts of system.</li>\n<li>Blind faith - Lack of checking of correctness of a bug fix or result of a subroutine.</li>\n<li>Boat anchor - Retaining a part of a system that is no longer has any use.</li>\n<li>Busy spin - Consuming CPU while waiting for something to happen, usually by repeated checking rather than message passing.</li>\n<li>Caching failure - Forgetting to reset an error flag when an error has been corrected.</li>\n<li>Cargo cult programming - Using patterns and methods without understanding why.</li>\n<li>Coding by exception - Adding a new code to handle each special case as it is recognised.</li>\n<li>Error hiding - Catching an error message before it can be shown to the user, either showing nothing or showing a meaningless message.</li>\n<li>Hard code - Embedding assumption about environment of a system in its implementation.</li>\n<li>Lava flow - Retaining undesirable code because removing it is too expensive or has unpredictable consequences.</li>\n<li>Loop switch sequence - Encoding a set of sequential steps using a switch within a loop.</li>\n<li>Magic numbers - Including unexplained numbers in algorithm.</li>\n<li>Magic strings - Including literal strings in code, for comparison, as event types etc.</li>\n<li>Soft code - Storing business logic in configuration files rather than source code.</li>\n<li>Spaghetti code - Programs whose structure is barely comprehensible.</li>\n</ul>\n<p><strong>Methodological anti-patterns</strong></p>\n<ul>\n<li>Copy-paste programming. Copying (modifying) and pasting existing code rather than implementing generic solution.</li>\n<li>Golden hammering - Assuming that a favourite solution is universally applicable.</li>\n<li>Improbability factor - Assuming that it is improbably that a known error will occur.</li>\n<li>NHI syndrome - The tendency towards reinventing the wheel, assuming it does not exist here before.</li>\n<li>Premature optimisation - Coding early on for a perceived efficiency, sacrificing good design, maintainability, and sometimes even real world efficiency.</li>\n<li>Programming by permutation - Trying to approach a solution by successively modifying the code to see if it works.</li>\n<li>Reinventing the wheel - Failing to adopt an existing, adequate solution.</li>\n<li>Reinventing the square wheel - Failing to adopt an existing solution and instead adopting a custom solution which performs much worse than an existing one.</li>\n<li>Silver bullet - Assuming that a favourite technical solution can solve a larger process or problem.</li>\n<li>Tester driven development - Projects in which new requirements are specified in bug reports.</li>\n</ul>\n<p>Phew… don’t stop here, explore more on internet as there can be more pitfalls that you might be already digging. Please share your findings in the comments section below.</p>","timeToRead":4,"frontmatter":{"date":"March 27, 2019","pathForPage":"2019-03-27-software-anti-patterns","title":"57 counterproductive software design practices - anti patterns.","subTitle":"deciding what not to do is as important as deciding what to do","tags":["microservices","design-patterns","technology","anti-patterns"],"categories":"design-patterns"}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"pathForPage":"2019-03-27-software-anti-patterns"}}}